---
title: "Reticulate"
subtitle: "The Marriage of Python and R"
author: "Jacob Resnikoff"
institute: "University of Oregon"
date: "Updated: 11 May 2021"
output:
  xaringan::moon_reader:
    css: [default, metropolis, metropolis-fonts]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---

```{r setup, echo=FALSE}
options(htmltools.dir.version = FALSE)

knitr::opts_chunk$set(
  echo = TRUE, # Show all R output
  message = FALSE, # Suppress messages (e.g. about namespace conflicts)
  warning = FALSE
) 
```

background-image: url('images/python-logo.png'), url('images/r-logo.png'), url('images/rivalry.jpg')
background-position: 120px 80px, 690px 80px, center
background-size: 80px 80px, 80px 80px, contain

# Rivalry

---
background-image: url('images/teamwork-hands.jpg')
background-position: 50% 100px
background-size: 1027px 533px

# Our Goal
 
By the end of today, you'll see that these two languages are **powerful in their own right**, and can **join forces to great effect**

---
# Roadmap

*Discussion*
1. Background on Reticulate
2. Virtual Environments
3. Comparing Data Types and Data Structures in Python and R
4. Data Wrangling in Python
5. Data Visualization in Python

*Live*
1. Load Python in RStudio
2. Demonstrate the Best of Both Worlds

---
class: inverse, center, middle

# Background on Reticulate
<html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>
---
# Background

A "comprehensive set of tools for interoperability between Python and R"<sup>1</sup>

.footnote[
<sup>1</sup> [Reticulate Documentation](https://rstudio.github.io/reticulate/index.html)
]
---
# Background

That's a little verbose, eh?

.footnote[
<sup>1</sup> [Reticulate Documentation](https://rstudio.github.io/reticulate/index.html)
]
--

When I read this, I see **a toolbox that *unites* R and Python**

--
background-image: url('images/reticulated_python.png')
background-size: 390px 278px
---
# Background

Reticulate allows one to:

--

* Call Python from R by:
  + using the Python Interpreter in the R Console
  + Importing Python Modules
  + R Markdown
--

* Translate between R and Python objects
  + R and pandas dataframes, R matrices and NumPy arrays
--

* Flexibly bind to different versions of Python, including those in virtual and Conda environments
---
background-image: url('images/blue-apron-box.jpg')
background-size: fill

# Virtual Environments

---
# Virtual Environments

This is **not** an ad for Blue Apron!

--

But I think the analogy still holds.

--

* Like pre-packaged meal boxes, virtual environments:
--

  + contain all the "ingredients" needed to operate the package
--

  + are therefore **convenient** and **reliable** for sharing your work
--
background-image: url('images/docker-logo.jpg')
background-position: 50% 300px
background-size: 500px 250px
* Docker plays with this idea as well
---
class: inverse, center, middle

# Getting Started
<html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>
---
# Getting Started

```{r load reticulate and condaenv, echo=TRUE}
# load reticulate
library(reticulate)

# load version of python
use_condaenv('C:\\Users\\DScience\\anaconda3\\envs\\Python', required = TRUE)
```

.pull-left[

## Python

```{python hello python}
print('Hello World!')
```

]

.pull-right[

## R

```{r hello r}
cat('Hello World')
```

]

--

.center[So far so good...]
---
# Lists

## Python

In Python we have lists, which can be composed of scalars or other objects:

```{python python list with scalars}
# lists - this list contains scalars of type integer, boolean, float, string, 
# and a list!
my_list = [27, True, 72.998, 'Jeff Jefferson III, Esquire', [3.2, 5.4]]
```

Notice the `=` we use for variable assignment; we use `==` for logical
comparisons, though. Also note that the boolean `True` has a single capital
letter.

## R

Aside from some syntax, we can do the same thing in R!

```{r r list with scalars}
# this list contains scalars of type integer, logical, numeric, character, 
# and a vector!
my_list <- list(27, TRUE, 72.998, 'Jeff Jefferson III, Esquire', c(3.2, 5.4))
```

Notice here the `<-` as well as the logical `TRUE` is fully capitalized.

---
# Hashmaps (also known as Dictionaries)

## Python

In Python dictionaries are built-in. They consist of key-value pairs:

```{python python dict}
# dictionary
my_dict = {
  'film': 'Top Gun',
  'release year': 1986,
  'star': 'Tom Cruise'}
```

## R

We have a similar object in R, although it is not a base R object type:

```{r r dict}
# we need an additional library, because hashmaps are not built-in as they are in python
library(hash)

my_hash <- hash(
  keys = c('film', 'release year', 'star'),
  values = c('Top Gun', 1986, 'Tom Cruise'))
```

---
# Arrays

## Python

Arrays are not built-in Python objects. Instead, we use the "ndarray" object
from NumPy â€” a Python package for scientific computing that isn't included in 
base Python:

```{python python array}
# arrays require the NumPy package
import numpy as np

a = np.array([1, 3, 5, 7, 9])

b = a/10

print(b, type(b))
```

Because of how the NumPy developers constructed them, NumPy arrays are
especially efficient with memory.

---
# Arrays

## R

Arrays are built-in to R, and are meant to store multi-dimensional data:

```{r r array}
# vectors are just 1-dimensional arrays!
arr <- array(seq(from = 1, to = 9, by = 2))

cat(arr/10)
class(arr)
```

---
# Functions and Control Flow

## Python

Notice the minimalist syntax...:

```{python python funcs and c-flow}

def sortOnFive(x):
    if x > 5:
        return 1
    elif x < 5:
        return -1
    else:
        return 0
         
print(sortOnFive(4), sortOnFive(5), sortOnFive(6))
```

---

# Functions and Control Flow

## R

In R, we make liberal use of curly braces:

```{r r funcs and c-flow}
# now the brackets come into play
sortOnFive <- function(x){
  if (x > 5){
    print(1)
  }
  else if (x < 5){
    print(-1)
  } else {
    print(0)
  }
}
cat(sortOnFive(4), sortOnFive(5), sortOnFive(6))
```

---

# Data Wrangling

For our examples today, we will be using a dataset on Toyota Corollas:

```{python, fetch data}
# load dependencies
import numpy as np
import pandas as pd

# assign data to pandas dataframe
df = pd.read_csv('data/toyota_corolla.csv')
print(type(df))
```

For data wrangling, we use pandas, which stands for Panel Data. It is analogous
to R's tidyverse and data.table libraries. 
See that we imported NumPy as well as pandas? This is because NumPy is a
dependency of pandas. Without it, pandas couldn't work its wrangling-magic.

---

# Calling the Head Method

```{python}
# call the head method
df.head()
```

Like in R, we can call head to access the first few rows of a dataframe. In
Python, though, it is referred to as a "method." We use the `.` notation to
access them.

**Methods are functions specific to a particular object type**

---
# Accessing an Attribute

Hard to see all the columns, right?

```{python}
# call columns attribute
print(df.columns)
```

---

# Value Counts and Sorting

```{python}
# find the number of cars manufactured in each year, in descending order
df['mfg_year'].value_counts().sort_values(ascending=False)
```

---

# Descriptive Statistics

```{python}
# dataframe of descriptive statistics
df.describe()
```

---

# Creating a New Column

```{python}
# divide price by weight for each observation
df['price_per_pound'] = df['price']/df['weight']

# access array
print(type(df.price_per_pound))
df.price_per_pound
```

---

# Data Visualization

